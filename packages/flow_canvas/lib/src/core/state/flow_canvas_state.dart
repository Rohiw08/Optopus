// ignore_for_file: invalid_annotation_target

import 'package:flow_canvas/flow_canvas.dart';
import 'package:flow_canvas/src/features/viewport/domain/viewport.dart';
import 'package:flow_canvas/src/features/connections/domain/connection_state.dart';
import 'package:flow_canvas/src/features/edges/domain/edge_index.dart';
import 'package:flow_canvas/src/features/edges/domain/edge_state.dart';
import 'package:flow_canvas/src/features/handles/domain/handle_state.dart';
import 'package:flow_canvas/src/features/nodes/domain/node_state.dart';
import 'package:flutter/painting.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:flow_canvas/src/features/nodes/domain/node_index.dart';
import 'package:flow_canvas/src/core/utils/json_converters.dart';
part 'flow_canvas_state.freezed.dart';

@freezed
abstract class FlowCanvasState with _$FlowCanvasState {
  const FlowCanvasState._();

  const factory FlowCanvasState({
    // Core graph data
    @Default({}) @NodeMapConverter() Map<String, FlowNode> nodes,
    @Default({}) Map<String, FlowEdge> edges,

    // Runtime node/edge/handle states
    @Default({})
    @JsonKey(ignore: true)
    Map<String, NodeRuntimeState> nodeStates,
    @Default({})
    @JsonKey(ignore: true)
    Map<String, EdgeRuntimeState> edgeStates,
    @Default({})
    @JsonKey(ignore: true)
    Map<String, HandleRuntimeState> handleStates,

    // Selection and z-ordering
    @Default({}) Set<String> selectedNodes,
    @Default({}) Set<String> selectedEdges,
    @Default(0) int minZIndex,
    @Default(0) int maxZIndex,

    // --- FIX START ---
    // Make these nullable so .fromJson can instantiate the class without them.
    // Since they are ignored in JSON, they will be null when loading from file.
    @JsonKey(includeFromJson: false, includeToJson: false) NodeIndex? nodeIndex,
    @JsonKey(includeFromJson: false, includeToJson: false) EdgeIndex? edgeIndex,
    // --- FIX END ---

    // Viewport
    @Default(FlowViewport()) FlowViewport viewport,
    @SizeConverter() Size? viewportSize,
    @Default(false) bool isPanZoomLocked,

    // Interaction state
    @Default(DragMode.none) @JsonKey(ignore: true) DragMode dragMode,
    @JsonKey(ignore: true) FlowConnection? activeConnection,
    @Default(FlowConnectionRuntimeState.idle())
    @JsonKey(ignore: true)
    FlowConnectionRuntimeState connectionState,
    @Default(Rect.zero)
    @RectConverter()
    @JsonKey(ignore: true)
    Rect selectionRect,
    @Default('') @JsonKey(ignore: true) String hoveredEdgeId,
    @Default('') @JsonKey(ignore: true) String lastClickedEdgeId,
  }) = _FlowCanvasState;

  // toJson is generated by Freezed via _$FlowCanvasStateMixin only if .g.dart exists.
  // Since we use manual serialization, we implement it here:
  Map<String, dynamic> toJson() {
    return {
      'nodes': const NodeMapConverter().toJson(nodes),
      'edges': edges.map((k, v) => MapEntry(k, v.toJson())),
      'viewport': viewport.toJson(),
      'isPanZoomLocked': isPanZoomLocked,
      'selectedNodes': selectedNodes.toList(),
      'selectedEdges': selectedEdges.toList(),
      'minZIndex': minZIndex,
      'maxZIndex': maxZIndex,
    };
  }

  factory FlowCanvasState.fromJson(Map<String, dynamic> json) {
    // Parse core graph data manually from JSON
    final nodesJson = json['nodes'] as Map<String, dynamic>? ?? {};
    final edgesJson = json['edges'] as Map<String, dynamic>? ?? {};

    // NodeMapConverter converts the WHOLE map at once
    final nodes = const NodeMapConverter().fromJson(nodesJson);
    final edges = edgesJson.map(
      (k, v) => MapEntry(
        k,
        FlowEdge.fromJson(v as Map<String, dynamic>),
      ),
    );

    // Parse viewport if present
    final viewportJson = json['viewport'] as Map<String, dynamic>?;
    final viewport = viewportJson != null
        ? FlowViewport.fromJson(viewportJson)
        : const FlowViewport();

    return FlowCanvasState(
      nodes: nodes,
      edges: edges,
      viewport: viewport,
      isPanZoomLocked: json['isPanZoomLocked'] as bool? ?? false,
      selectedNodes: ((json['selectedNodes'] as List<dynamic>?) ?? [])
          .map((e) => e as String)
          .toSet(),
      selectedEdges: ((json['selectedEdges'] as List<dynamic>?) ?? [])
          .map((e) => e as String)
          .toSet(),
      minZIndex: json['minZIndex'] as int? ?? 0,
      maxZIndex: json['maxZIndex'] as int? ?? 0,
      // Re-derive runtime state from the parsed graph
      nodeStates: {
        for (final n in nodes.values) n.id: const NodeRuntimeState()
      },
      edgeStates: {
        for (final e in edges.values) e.id: const EdgeRuntimeState()
      },
      nodeIndex: NodeIndex.fromNodes(nodes.values),
      edgeIndex: EdgeIndex.fromEdges(edges),
    );
  }

  factory FlowCanvasState.initial() => FlowCanvasState(
        nodeIndex: NodeIndex.empty(),
        edgeIndex: EdgeIndex.empty(),
      );
}
